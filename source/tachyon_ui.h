
#pragma

namespace tyon
{
template<>
struct entity_type_definition<window>
{
  using t_entity = window;
  using t_context = entity_type_context<t_entity>;
  static constexpr cstring name = "tyon::window";
  static constexpr u128 id = uuid("965fd378-6573-4844-aa34-e6645cc3ac7a");

PROC allocate() -> void
{}

PROC init( t_entity* arg ) -> fresult
{
  return false;
}
PROC destroy( t_entity* arg ) -> void
{
  auto sdl = sdl_create_platform_subsystem();
  sdl.window_close( arg );
  *arg = {};
}

PROC tick() -> void
{}

static PROC context_tick( void* context ) -> void
{}

static PROC destroy_all( void* context ) -> void
{}

};

/** An action is a generic interface into binding events that happen to user facing input.
 *
 * A centralized system allows to making any user-interactable hook-able
 * into the many various user interaction systems that are available, user defined
 * buttons, keyboard shortcuts, pen gestures, command windows, etc.
 */
struct action
{
  // Static ID consistent across program runs
  uid id;
  fstring name;
  fstring display_name;
  fstring description;
  /** What contextual part of the program or UI the action is valid for.

    Actions can only be meaningful in specific UI contexts, so we need to store
   what context the actual belongs to, and if that context is currently
   acecssible. ie Fly Camera Controls are only valid when controlling a camera,
   but we can still bind a to different action trigger whilst in the wrong
   content- but only if the context still physically exists.

   That will be handled in external triggers but the action stores what it's supposed to be. */
  // e_action_context context;

  // Means one of the following possible triggers have been bound
  bool triggered = false;
  bool event_bound = false;
  // These triggers need to be serializable functions
  tyon::delegate<void()> trigger;
  // NOTE: Actions should not who invokes the action, they should instead link to the action.
};

enum class f_mouse_button : i32
{
  left   = (1 << 0),
  middle = (1 << 1),
  right  = (1 << 2),
  side1  = (1 << 3),
  side2  = (1 << 4),
};

struct keybind_chain_step
{
  SDL_Scancode scancode;
  /** Not reliable way to setup keybinds, but might be useful if the user wants to remap to a named
      key with different keyboard layouts. */
  SDL_Keycode keycode;
  /// Hold down with next chain and ignore most attributes except combnie_next
  bool combine_next = false;
  /// if 0.0 is a keypress only
  f32 hold_time = 0.0;
};


struct keybind
{
  action bound_action;
  /// Describes the multi-part keybind that makes up the keybind
  array<keybind_chain_step> chain;
};

struct gesture_chain_step
{
    v3_f32 position;
    /** Some gestures are only valid if travelling in a specified direction.
     This can be autogenerated from the gesture chain if necessary. */
    bool directional = false;
    v3_f32 direction;
};

struct gesture
{
  array<gesture_chain_step> chain;
};

enum class e_ui_drawable : i32
{
  none      = 0,
  any       = 1,
  image     = 2,
  vector    = 3,
  mesh      = 4,
  text      = 5
};

/** A standard rgba color container.

    It's more convenient to use it abgra because that's the little endian
representation and it also means it plainly.  WARNING: This breaks on big endian
systems. Things like Vulkan plainly only support */

#if (REFLECTION_LITTLE_ENDIAN)
struct rgba
{
    union {
        struct { u8 a; u8 b; u8 g; u8 r; };
        u32 hex;
    };
};
#else
struct rgba
{
    union {
        struct { u8 r; u8 g; u8 b; u8 a };
        u32 hex;
    };
};
#endif // REFLECTION_LITTLE_ENDIAN

struct ui_drawable
{
    e_ui_drawable type = drawable::none;
    image<rgba> image_;
    text_drawable text;
    rgba8 color;

    transform_2d transform;
    i32 depth = 0;
};

struct ui_frame
{
  array<ui_drawable> draw_queue;
  vector<u8> scancode_states;
  vector<u8> scancode_single_press;
  f_mouse_button mouse_button_state;
  f_mouse_button mouse_button_single_press;

  vec2 window_size = 0;
  vec2 window_halfsize = 0;

  time_monotonic tooltip_hover_time = time_now();
  vec2 cursor;
  vec2 cursor_canvas;
  f32 canvas_scale;
  vec2 canvas_position;
  vec2 canvas_origin = 0;
  vec2 mouse_delta = 0;
  vec2 mouse_delta_canvas = 0;
  f32 scroll_x = 0;
  f32 scroll_y = 0;
  // if scroll has been read this frame
  bool scroll_consumed = false;
};
}
